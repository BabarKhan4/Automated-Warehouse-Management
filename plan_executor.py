# plan_executor.py
import time 
import re 
import os # For future debugging or file checks

def parse_plan(plan_file):
    """
    Parses the plan file generated by Fast Downward into a list of actions and parameters.
    Returns: list: List of actions [(action, params), ...]
    """
    actions = []
    try:
        with open(plan_file, 'r') as f:
            for line in f:
                line = line.strip()
                
                # Ignore comment lines and empty lines
                if not line or line.startswith(';'):
                    continue
                
                # Remove parentheses if present
                line = line.strip('()')
                
                # Separate action and parameters
                parts = line.split()
                
                if len(parts) > 0:
                    action_name = parts[0].lower() # Ensure case-insensitivity
                    # Normalize parameters to lowercase to match in-memory IDs
                    params = [p.lower() for p in parts[1:]]
                    actions.append((action_name, params))
    except FileNotFoundError:
        # print(f"Error: Plan file not found at {plan_file}")
        return None
    except Exception as e:
        # print(f"Error during plan parsing: {e}")
        return None

    return actions

# -------------------------------------------------------------------

class PlanExecutor: 
    def __init__(self, environment, robots, packages, gui_instance=None):
        self.environment = environment 
        # Normalize robot and package ids to lowercase for case-insensitive matching
        self.robots = {r.id.lower(): r for r in robots}
        self.packages = {p.id.lower(): p for p in packages} 
        self.gui = gui_instance

    def _parse_zone(self, zone_name):
        """Extracts coordinates (x, y) from a zone name like 'zone_2_3'."""
        parts = zone_name.split('_')
        if len(parts) == 3:
            return (int(parts[1]), int(parts[2]))
        raise ValueError(f"Invalid zone format: {zone_name}")
    
    def _get_direction(self, from_pos, to_pos):
        """Calculates the movement direction ('up', 'down', 'left', 'right')."""
        dx = to_pos[0] - from_pos[0]
        dy = to_pos[1] - from_pos[1]

        if dx > 0: return 'right'
        elif dx < 0: return 'left'
        elif dy > 0: return 'up'
        elif dy < 0: return 'down'
        return None

    def execute_action(self, action_name, params): 
        """Executes a single PDDL action in the simulation."""
        success = False
        try: 
            if action_name == 'move':
                robot_id, from_zone, to_zone = params
                robot = self.robots.get(robot_id.lower())
                if robot is None:
                    # Debug: show what keys we have to diagnose mismatches
                    print(f"DEBUG: robot lookup failed for '{robot_id}'. Known robot keys: {list(self.robots.keys())}")
                    raise KeyError(robot_id)
                from_coords = self._parse_zone(from_zone)
                to_coords = self._parse_zone(to_zone)

                # Runtime check: PDDL plan must be consistent with current state
                if robot.position != from_coords:
                    print(f"ERROR: Robot {robot_id} expected at {from_coords} but found at {robot.position}")
                    return False 
                
                direction = self._get_direction(from_coords, to_coords)
                success = robot.move(direction, self.environment)

            elif action_name == "pickup":
                robot_id, package_id, location = params
                robot = self.robots.get(robot_id.lower())
                package = self.packages.get(package_id.lower())
                if robot is None or package is None:
                    print(f"DEBUG: pickup/drop lookup failed for {robot_id},{package_id}.\n  robots: {list(self.robots.keys())}\n  packages: {list(self.packages.keys())}")
                    raise KeyError((robot_id, package_id))
                success = robot.pickup(package)

            elif action_name == "drop":
                robot_id, package_id, location = params 
                robot = self.robots.get(robot_id.lower())
                package = self.packages.get(package_id.lower())
                if robot is None or package is None:
                    raise KeyError((robot_id, package_id))
                success = robot.drop(package)

            else:
                print(f"Unknown action: {action_name}")
                return False 
            return success
        except Exception as e:
            print(f"Error executing action {action_name} with params {params}: {e}")
            return False
        
    def execute_plan(self, plan, delay=0.5): 
        """Executes the entire parsed plan with visualization."""
        for i, (action, params) in enumerate(plan):
            step_info = f"Step {i+1}/{len(plan)}: ({action} {' '.join(params)})"
            print(step_info)
            if self.gui:
                self.gui.update_info(f"Executing: {step_info}")

            success = self.execute_action(action, params)

            if not success:
                print(f"FAILURE at step {i+1}. Plan execution halted.")
                if self.gui:
                    self.gui.update_info(f"Failure at step {i+1}. Check terminal.")
                return False 
            
            # Redraw and pause for animation
            if self.gui:
                self.gui.draw()
                time.sleep(delay)

        print("Plan executed successfully.")
        if self.gui:
            # mark that a plan executed successfully so GUI can respond (e.g., Reset behavior)
            try:
                self.gui.last_execution_success = True
            except Exception:
                pass
            self.gui.update_info("Plan executed successfully! Mission complete.")
        return True